{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mycorrhizae are a symbiotic association between plant roots and fungi . Their major role is to enhance nutrient and water uptake by the host plant by exploiting a larger volume of soil than roots alone can do. Mycorrhizae come in a number of forms, dependent upon both host plant and fungal taxonomy. -- J. Dighton, in Encyclopedia of Microbiology (Third Edition), 2009 Mycoriza. Mycoriza is a typescript library / code generator for integrating Rest API to react applications. Painless : Mycoriza makes the Rest API integration ridiculously easy by providing a toolset to generate more react-ish, well documented network layer boilerplate. This helps the developers to spend there valuable time on more important problems than network integration. Explicit : In react applications, classic way of handling the asynchronous behavior is often confusing and requires more effort in maintaining. Mycoriza incorporates more explicit approach by modeling the promises as states, and provides the necessary tools to mine information in typesafe manner. Safe : Mycoriza ensures the type-safety through strong typescript support and integration-safety through easy and typesafe API client generation.","title":"Overview"},{"location":"#mycoriza","text":"Mycoriza is a typescript library / code generator for integrating Rest API to react applications. Painless : Mycoriza makes the Rest API integration ridiculously easy by providing a toolset to generate more react-ish, well documented network layer boilerplate. This helps the developers to spend there valuable time on more important problems than network integration. Explicit : In react applications, classic way of handling the asynchronous behavior is often confusing and requires more effort in maintaining. Mycoriza incorporates more explicit approach by modeling the promises as states, and provides the necessary tools to mine information in typesafe manner. Safe : Mycoriza ensures the type-safety through strong typescript support and integration-safety through easy and typesafe API client generation.","title":"Mycoriza."},{"location":"TODOS/","text":"Todos [ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"TODOS/#todos","text":"[ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"concepts/","text":"Introduction Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in. Generates the Boilerplate There are various tools and tactics used in developing the network layer of react applications. Most of those solutions provides a library to use and conventions to follow. The other solutions provides the code generation as a solution. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library. Encourages Standardized API Integration. Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. OpenAPI is a widely used matured toolset / specification for API documentation. Mycoriza uses swagger 3+ API specification for boilerplate generation. Uses stable stack. The libraries like redux and axios have already mastered there usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration. Simple and Expressive Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience. Uses more simplified and standard hook API, which is more natural to the react. Every generated hook follows similar syntax much similar to the useState hook. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/); Favors States to Promises In javascript, promise represents a possibility and the time aspect is embedded to the promise itself. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state. Type safe. Mycoriza is written with strong type safety in mind. It supports typescript:4+ and makes use of the features like type guards to provide better type safety. Well documented. Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks. Performant Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting","title":"Concepts"},{"location":"concepts/#introduction","text":"Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in.","title":"Introduction"},{"location":"concepts/#generates-the-boilerplate","text":"There are various tools and tactics used in developing the network layer of react applications. Most of those solutions provides a library to use and conventions to follow. The other solutions provides the code generation as a solution. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library.","title":"Generates the Boilerplate"},{"location":"concepts/#encourages-standardized-api-integration","text":"Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. OpenAPI is a widely used matured toolset / specification for API documentation. Mycoriza uses swagger 3+ API specification for boilerplate generation.","title":"Encourages Standardized API Integration."},{"location":"concepts/#uses-stable-stack","text":"The libraries like redux and axios have already mastered there usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration.","title":"Uses stable stack."},{"location":"concepts/#simple-and-expressive","text":"Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience.","title":"Simple and Expressive"},{"location":"concepts/#uses-more-simplified-and-standard-hook-api-which-is-more-natural-to-the-react","text":"Every generated hook follows similar syntax much similar to the useState hook. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/);","title":"Uses more simplified and standard hook API, which is more natural to the react."},{"location":"concepts/#favors-states-to-promises","text":"In javascript, promise represents a possibility and the time aspect is embedded to the promise itself. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state.","title":"Favors States to Promises"},{"location":"concepts/#type-safe","text":"Mycoriza is written with strong type safety in mind. It supports typescript:4+ and makes use of the features like type guards to provide better type safety.","title":"Type safe."},{"location":"concepts/#well-documented","text":"Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks.","title":"Well documented."},{"location":"concepts/#performant","text":"Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting","title":"Performant"},{"location":"getting-started/","text":"Getting Started The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup. Prerequisites Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed. How to create a project. Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza Post-creation steps. The API client hooks and types can be generated by running following command. cd <project-name> npm run updateApi When the updateApi command runs for the first time, it requests the following configurations. OpenAPI url : the location where the OpenAPI specification can be found. Only the hosted specifications are supported and file based specification configuraiton is under development. Development URL : The server url which the application connect to within the development environment. Production URL : The server url of the production system. If the production url is empty, it uses the application hosted domain as the production URL. Once you complete these steps, you can find the following generated code. Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup.","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed.","title":"Prerequisites"},{"location":"getting-started/#how-to-create-a-project","text":"Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza","title":"How to create a project."},{"location":"getting-started/#post-creation-steps","text":"The API client hooks and types can be generated by running following command. cd <project-name> npm run updateApi When the updateApi command runs for the first time, it requests the following configurations. OpenAPI url : the location where the OpenAPI specification can be found. Only the hosted specifications are supported and file based specification configuraiton is under development. Development URL : The server url which the application connect to within the development environment. Production URL : The server url of the production system. If the production url is empty, it uses the application hosted domain as the production URL. Once you complete these steps, you can find the following generated code. Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Post-creation steps."},{"location":"network-states/","text":"A word about NetworkState By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural. Network State Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call. Typesafe Utilities Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows isInit This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; } isPending This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; } isSuccess This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; } isError This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; }","title":"API Response Handling"},{"location":"network-states/#a-word-about-networkstate","text":"By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural.","title":"A word about NetworkState"},{"location":"network-states/#network-state","text":"Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call.","title":"Network State"},{"location":"network-states/#typesafe-utilities","text":"Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows","title":"Typesafe Utilities"},{"location":"network-states/#isinit","text":"This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; }","title":"isInit"},{"location":"network-states/#ispending","text":"This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; }","title":"isPending"},{"location":"network-states/#issuccess","text":"This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; }","title":"isSuccess"},{"location":"network-states/#iserror","text":"This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; }","title":"isError"},{"location":"patterns-and-best-practices/","text":"Patterns and Best Practices. Throughout our usage of this framework, we have identified several patterns which can be used with the networks state. Conditional returns based on the state. You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; } Conditional rendering within jsx. In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Eager fetching. In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Cleanup upon exit. In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application. Hide intermediate pending state. In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; } Prefer hook for each necessary component over pass-through-props. As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good. Use entityKey to load multiple results for same api. In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Patterns and Best Practices"},{"location":"patterns-and-best-practices/#patterns-and-best-practices","text":"Throughout our usage of this framework, we have identified several patterns which can be used with the networks state.","title":"Patterns and Best Practices."},{"location":"patterns-and-best-practices/#conditional-returns-based-on-the-state","text":"You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; }","title":"Conditional returns based on the state."},{"location":"patterns-and-best-practices/#conditional-rendering-within-jsx","text":"In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Conditional rendering within jsx."},{"location":"patterns-and-best-practices/#eager-fetching","text":"In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Eager fetching."},{"location":"patterns-and-best-practices/#cleanup-upon-exit","text":"In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application.","title":"Cleanup upon exit."},{"location":"patterns-and-best-practices/#hide-intermediate-pending-state","text":"In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; }","title":"Hide intermediate pending state."},{"location":"patterns-and-best-practices/#prefer-hook-for-each-necessary-component-over-pass-through-props","text":"As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good.","title":"Prefer hook for each necessary component over pass-through-props."},{"location":"patterns-and-best-practices/#use-entitykey-to-load-multiple-results-for-same-api","text":"In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Use entityKey to load multiple results for same api."}]}