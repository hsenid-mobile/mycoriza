{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mycoriza Mycorrhizae are a symbiotic association between plant roots and fungi . Their major role is to enhance nutrient and water uptake by the host plant by exploiting a larger volume of soil than roots alone can do. Mycorrhizae come in a number of forms, dependent upon both host plant and fungal taxonomy.\" -- J. Dighton, in Encyclopedia of Microbiology (Third Edition), 2009 Mycoriza is a typescript library / code generator for integrating Rest API to react applications. Getting Started Painless Mycoriza makes the Rest API integration ridiculously easy and helps the developers to spend there valuable time on more important problems than network integration. Explicit Mycoriza prefers State based approach to Promise handling, which is natural to react. Safe Mycoriza ensures the type-safety through strong typescript support and integration-safety through easy and typesafe API client generation.","title":"Overview"},{"location":"#_1","text":"Mycoriza is a typescript library / code generator for integrating Rest API to react applications. Getting Started Painless Mycoriza makes the Rest API integration ridiculously easy and helps the developers to spend there valuable time on more important problems than network integration. Explicit Mycoriza prefers State based approach to Promise handling, which is natural to react. Safe Mycoriza ensures the type-safety through strong typescript support and integration-safety through easy and typesafe API client generation.","title":""},{"location":"TODOS/","text":"Todos [ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"TODOS/#todos","text":"[ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"cli-usage/","text":"Mycoriza CLI. Mycoriza provides a CLI to generate to the boilerplate and collect necessary configurations. The updateApi task generated by the Mycoriza cra template uses the CLI under the hood. The CLI currently contains following commands. Usage It is advised to run the mycoriza commands with npx . Warning Mycoriza tool can be added as a project dev dependency and execute through yarn. However, due to a limitation of yarn, the command may not complete. $ npx mycoriza [ command ] Following commands are available within the tool. Command Behavior Description add interactive Add swagger source to mycoriza configuration rm interactive Remove swagger source. ls single command List current mycoriza sources. generate:api single command Generates the client types and hooks. Manage Sources Add swagger source. Interactive $ npx mycoriza add Single Command $ npx mycoriza add -s <swagger-source-url> -d <dev-url> -p <prod-url> --id <source-id> This is an interactive command and during the operation following information are collected. Option CLI Option Descriptino Swagger Specification URL --source -s Specification URL for the swagger documentation. Development Base URL --dev-url -d Base url to connect during the development. Production Base URL --prod-url -p Base url to connect during the production. id --id ID of the source. This id will be used as the directory of the generated source and therefore camalcase value is required Note The generated configuration is saved in mycoriza.config.json . in the root of the project directory. List swagger sources. $ npx mycoriza ls This command will list down all the mycoriza configurations already configured in the project. Remove swagger sources. Interactive $ npx mycoriza rm Single Command $ npx mycoriza rm <source-id> This command will prompt a selection to remove specific swagger source from the configuration. Note Please consider that the npx mycoriza rm does not remove the existing generated sources. This is an interactive command and during the operation following information are collected Option CLI Option Description Source [id] ID of the source to be removed Warning All the mycoriza configurations are saved in mycoriza.config.json . Even though, it is tempting to update the sources of the file directly, it is advised to use the mycoriza cli tool, is it provides additional validations over the configurations. Generate APIs Use following command to generate the API hooks. $ npx mycoriza generate:api [ ...sources ] Option CLI Option Description sources [...source] List of sources to be fetched. If the list is empty, the clients for all the configured sources are regenerated. This command will generate the source necessary sources for related to swagger documentations. The generated code can be found in src/api/<source-id>/ directory.","title":"CLI Usage"},{"location":"cli-usage/#mycoriza-cli","text":"Mycoriza provides a CLI to generate to the boilerplate and collect necessary configurations. The updateApi task generated by the Mycoriza cra template uses the CLI under the hood. The CLI currently contains following commands.","title":"Mycoriza CLI."},{"location":"cli-usage/#usage","text":"It is advised to run the mycoriza commands with npx . Warning Mycoriza tool can be added as a project dev dependency and execute through yarn. However, due to a limitation of yarn, the command may not complete. $ npx mycoriza [ command ] Following commands are available within the tool. Command Behavior Description add interactive Add swagger source to mycoriza configuration rm interactive Remove swagger source. ls single command List current mycoriza sources. generate:api single command Generates the client types and hooks.","title":"Usage"},{"location":"cli-usage/#manage-sources","text":"","title":"Manage Sources"},{"location":"cli-usage/#add-swagger-source","text":"Interactive $ npx mycoriza add Single Command $ npx mycoriza add -s <swagger-source-url> -d <dev-url> -p <prod-url> --id <source-id> This is an interactive command and during the operation following information are collected. Option CLI Option Descriptino Swagger Specification URL --source -s Specification URL for the swagger documentation. Development Base URL --dev-url -d Base url to connect during the development. Production Base URL --prod-url -p Base url to connect during the production. id --id ID of the source. This id will be used as the directory of the generated source and therefore camalcase value is required Note The generated configuration is saved in mycoriza.config.json . in the root of the project directory.","title":"Add swagger source."},{"location":"cli-usage/#list-swagger-sources","text":"$ npx mycoriza ls This command will list down all the mycoriza configurations already configured in the project.","title":"List swagger sources."},{"location":"cli-usage/#remove-swagger-sources","text":"Interactive $ npx mycoriza rm Single Command $ npx mycoriza rm <source-id> This command will prompt a selection to remove specific swagger source from the configuration. Note Please consider that the npx mycoriza rm does not remove the existing generated sources. This is an interactive command and during the operation following information are collected Option CLI Option Description Source [id] ID of the source to be removed Warning All the mycoriza configurations are saved in mycoriza.config.json . Even though, it is tempting to update the sources of the file directly, it is advised to use the mycoriza cli tool, is it provides additional validations over the configurations.","title":"Remove swagger sources."},{"location":"cli-usage/#generate-apis","text":"Use following command to generate the API hooks. $ npx mycoriza generate:api [ ...sources ] Option CLI Option Description sources [...source] List of sources to be fetched. If the list is empty, the clients for all the configured sources are regenerated. This command will generate the source necessary sources for related to swagger documentations. The generated code can be found in src/api/<source-id>/ directory.","title":"Generate APIs"},{"location":"concepts/","text":"Introduction Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in. Generates the Boilerplate There are various tools and tactics used in developing the network layer of react applications. Those solutions provide either a library to use and conventions to follow, or code generation. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library. Encourages Standardized API Integration. Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. Only the OpenAPI v3 is supported at the moment. OpenAPI v2 support is under development. At the moment, the specification should be accessible through http. File based specification is under development. Uses stable stack. The libraries like redux and axios have already mastered their usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration. While Mycoriza uses these technologies, it does not affect the capabilities which those libraries provide. You can use those libraries with their usual behaviors. Simple and Expressive Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience. Uses hooks . Every generated hook follows a consistent syntax much similar to the useState hook. This allows a seamless integration with the react components and provides a pleasant development experience. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/); Favors States to Promises In javascript, promise represents a possibility and the time aspect. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state. Type safe. Mycoriza is written with strong type safety in mind. It supports and makes use of the features like type guards to provide better type safety. Well documented. Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks. Performant Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting. In the end we believe in productivity and performance in both runtime and development/maintenance. Therefore, Mycoriza tries to reduce and furthermore dissipate the complexity of the network integration altogether.","title":"Basic Concepts"},{"location":"concepts/#introduction","text":"Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in.","title":"Introduction"},{"location":"concepts/#generates-the-boilerplate","text":"There are various tools and tactics used in developing the network layer of react applications. Those solutions provide either a library to use and conventions to follow, or code generation. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library.","title":"Generates the Boilerplate"},{"location":"concepts/#encourages-standardized-api-integration","text":"Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. Only the OpenAPI v3 is supported at the moment. OpenAPI v2 support is under development. At the moment, the specification should be accessible through http. File based specification is under development.","title":"Encourages Standardized API Integration."},{"location":"concepts/#uses-stable-stack","text":"The libraries like redux and axios have already mastered their usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration. While Mycoriza uses these technologies, it does not affect the capabilities which those libraries provide. You can use those libraries with their usual behaviors.","title":"Uses stable stack."},{"location":"concepts/#simple-and-expressive","text":"Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience.","title":"Simple and Expressive"},{"location":"concepts/#uses-hooks","text":"Every generated hook follows a consistent syntax much similar to the useState hook. This allows a seamless integration with the react components and provides a pleasant development experience. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/);","title":"Uses hooks."},{"location":"concepts/#favors-states-to-promises","text":"In javascript, promise represents a possibility and the time aspect. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state.","title":"Favors States to Promises"},{"location":"concepts/#type-safe","text":"Mycoriza is written with strong type safety in mind. It supports and makes use of the features like type guards to provide better type safety.","title":"Type safe."},{"location":"concepts/#well-documented","text":"Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks.","title":"Well documented."},{"location":"concepts/#performant","text":"Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting. In the end we believe in productivity and performance in both runtime and development/maintenance. Therefore, Mycoriza tries to reduce and furthermore dissipate the complexity of the network integration altogether.","title":"Performant"},{"location":"contributions/","text":"How to Contribute.","title":"How to Contribute."},{"location":"contributions/#how-to-contribute","text":"","title":"How to Contribute."},{"location":"getting-started/","text":"Getting Started The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup. Prerequisites Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed. How to create a project. Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza Post-creation steps. The mycoriza template contains the basic setup to boot up a mycoriza project. To add initial swagger source, run following command 1. Add sources. cd <project-name> npx mycoriza add This will generate mycoriza.config.json , which contains the configuration of general flags and sources. While adding the sources to mycoriza, the necessary configurations related to the source are collected interactively. Please refer CLI Usage for further information. The API client hooks and types can be generated by running following command. 2. Update API to generate the sources. npm run updateApi Once you complete these steps, you can find the following generated code. Information about generated code. Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup.","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed.","title":"Prerequisites"},{"location":"getting-started/#how-to-create-a-project","text":"Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza","title":"How to create a project."},{"location":"getting-started/#post-creation-steps","text":"The mycoriza template contains the basic setup to boot up a mycoriza project. To add initial swagger source, run following command","title":"Post-creation steps."},{"location":"getting-started/#1-add-sources","text":"cd <project-name> npx mycoriza add This will generate mycoriza.config.json , which contains the configuration of general flags and sources. While adding the sources to mycoriza, the necessary configurations related to the source are collected interactively. Please refer CLI Usage for further information. The API client hooks and types can be generated by running following command.","title":"1. Add sources."},{"location":"getting-started/#2-update-api-to-generate-the-sources","text":"npm run updateApi Once you complete these steps, you can find the following generated code.","title":"2. Update API to generate the sources."},{"location":"getting-started/#information-about-generated-code","text":"Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Information about generated code."},{"location":"how-to-test/","text":"Testing components with Mycoriza hooks. Unit testing is a crucial part of software development. Being a state based library, Mycoriza provides the necessary tools to write the unit tests for the components using the mycoriza generated hooks. Mycoriza is backed by redux and redux provides a comprehensive guide on writing testis . It is recommended to refer the material. Setting up the tests. Mycoriza provides a testStore which accepts the generated reducer , middlewares and the stubs which are related to the CUD. Warning Make sure not to include the middlewares which are bound to issue remote calls as it affects the unit testing. Tip The generated stubs are meant to stub the redux-axios-middleware with more control. The testStore can be used alongside the react-redux Provider to create the tests, and the stubs should be initialized with the factory generated. import {render} from '@testing-library/react'; import {Provider} from \"react-redux\"; import {testStore} from \"mycoriza-runtime\"; //Import stubForMyHook ... let myHookStub = stubForMyHook() render(<Provider store={testStore({ rootReducer: rootReducer, stubs: [stubForMyHook] })}><MyComponent/></Provider>); //Use stub within the test ... The created stub can be used within the test. Autogenerated stubs for hooks. Mycoriza generates the stubs alongside the hooks in <hook-name>.test.ts file. These stubs provide following functionalities. get current state. The stub contains the method currentState to get the current network state in the store. currentState method accepts an entityKey , which can be used to identify the unique values. The currentState is a NetworkState and utility functions can be used with the states. import {isSuccess} from \"mycoriza-runtime\"; ... expect(isSuccess(myHookStub.currentState())).toBeTruthy() change states The stub provides four methods to change the state. Each method accepts the entityKey with usual meaning. reset Reset function will set the state to init state myHookStub.reset() toPendingState toPendingState function changes the state to pending state. myHookStub.toPendingState() toSuccessState toSuccessState function changes the state to success state. This function accepts a value of the type T of hook, and stores as the current value. myHookStub.toSuccessState(\"Foo\") toErrorState toErrorState function changes the state to error state. this function accepts a value as an error and stores as the current error. myHookStub.toErrorState(\"Some Error\") Conclusion The Mycoriza test environment is designed to be able to integrate with any testing environment which redux supports, like @react-testing or enzime . Altogether, writing unit tests to observe the behaviors of the components is a best practice and encouraged by Mycoriza. For any enhancement or issue please report an issue in github repository.","title":"Testing Components"},{"location":"how-to-test/#testing-components-with-mycoriza-hooks","text":"Unit testing is a crucial part of software development. Being a state based library, Mycoriza provides the necessary tools to write the unit tests for the components using the mycoriza generated hooks. Mycoriza is backed by redux and redux provides a comprehensive guide on writing testis . It is recommended to refer the material.","title":"Testing components with Mycoriza hooks."},{"location":"how-to-test/#setting-up-the-tests","text":"Mycoriza provides a testStore which accepts the generated reducer , middlewares and the stubs which are related to the CUD. Warning Make sure not to include the middlewares which are bound to issue remote calls as it affects the unit testing. Tip The generated stubs are meant to stub the redux-axios-middleware with more control. The testStore can be used alongside the react-redux Provider to create the tests, and the stubs should be initialized with the factory generated. import {render} from '@testing-library/react'; import {Provider} from \"react-redux\"; import {testStore} from \"mycoriza-runtime\"; //Import stubForMyHook ... let myHookStub = stubForMyHook() render(<Provider store={testStore({ rootReducer: rootReducer, stubs: [stubForMyHook] })}><MyComponent/></Provider>); //Use stub within the test ... The created stub can be used within the test.","title":"Setting up the tests."},{"location":"how-to-test/#autogenerated-stubs-for-hooks","text":"Mycoriza generates the stubs alongside the hooks in <hook-name>.test.ts file. These stubs provide following functionalities.","title":"Autogenerated stubs for hooks."},{"location":"how-to-test/#get-current-state","text":"The stub contains the method currentState to get the current network state in the store. currentState method accepts an entityKey , which can be used to identify the unique values. The currentState is a NetworkState and utility functions can be used with the states. import {isSuccess} from \"mycoriza-runtime\"; ... expect(isSuccess(myHookStub.currentState())).toBeTruthy()","title":"get current state."},{"location":"how-to-test/#change-states","text":"The stub provides four methods to change the state. Each method accepts the entityKey with usual meaning.","title":"change states"},{"location":"how-to-test/#reset","text":"Reset function will set the state to init state myHookStub.reset()","title":"reset"},{"location":"how-to-test/#topendingstate","text":"toPendingState function changes the state to pending state. myHookStub.toPendingState()","title":"toPendingState"},{"location":"how-to-test/#tosuccessstate","text":"toSuccessState function changes the state to success state. This function accepts a value of the type T of hook, and stores as the current value. myHookStub.toSuccessState(\"Foo\")","title":"toSuccessState"},{"location":"how-to-test/#toerrorstate","text":"toErrorState function changes the state to error state. this function accepts a value as an error and stores as the current error. myHookStub.toErrorState(\"Some Error\")","title":"toErrorState"},{"location":"how-to-test/#conclusion","text":"The Mycoriza test environment is designed to be able to integrate with any testing environment which redux supports, like @react-testing or enzime . Altogether, writing unit tests to observe the behaviors of the components is a best practice and encouraged by Mycoriza. For any enhancement or issue please report an issue in github repository.","title":"Conclusion"},{"location":"migration-guide/","text":"","title":"Migrate an existing project"},{"location":"network-states/","text":"A word about NetworkState By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural. Network State Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call. Typesafe Utilities Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows isInit This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; } isPending This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; } isSuccess This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; } isError This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; } Interoperability While the NetworkStates s are tempting, there might be instances where you still need to use Promises . Therefore, Mycoriza provides two additional hooks to support this interoperability. useAsNetworkState hook Features like async-storage and permissions in react-native uses Promise . To port those features to the NetworkState , Mycoriza provides useAsNetworkState hook. This hook accepts a function which provides a promise, and returns the regular Mycoriza hook results. The hook can be used as below. function MyComponent() { const [state, execute] = useAsNetworkState(() => new Promise((resolve, reject) => { ... }) useEffect(() => { if(isSuccess(state)) { //do on success } else if (isError(state)) { //do on error } }, [state.state]) return null; } useAsPromise hook When dealing with asynchronous behaviors, most of the libraries out there requires promises. In order to support this functionality, Mycoriza provides useAsPromise hook. This hook accepts a regular Mycoriza generated hook result and returns a function which creates a Promise . Each time the result function is called, it creates a promise and upon network sate change to terminated state, the promise completes. The hook can be used as below. function MyComponent() { const fetchData = useAsPromise(useDataAsNetworkState()); useEffect(() => { fetchData().then(data => { //Do on data }).catch(e => { //Do on error }) }, []) return null; } useAsNullable hook. useAsNullable hook is defined for a common but a specific case. Generally, a top level component in the component hierarchy handles the network status and the components in the success branch does not have any interest in the failure cases. In such components, having the status checks is unnecessary. Therefore, the useAsNullable hook is defined to convert the NetworkState to nullable value. With useAsNullable hook, the first parameter of the result is unwrapped. if the state is a success, the data in the state is returned; otherwise, undefined is returned. This hook can be used as below. function MyComponent() { const [data, fetch, clear] = useAsNullable(useDataAsNetworkState()); useEffect(() => { //Fetch Data. fetch() }, []) return <>{!!data && <>{JSON.stringify(data)}</>}</>; }","title":"API Response Handling"},{"location":"network-states/#a-word-about-networkstate","text":"By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural.","title":"A word about NetworkState"},{"location":"network-states/#network-state","text":"Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call.","title":"Network State"},{"location":"network-states/#typesafe-utilities","text":"Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows","title":"Typesafe Utilities"},{"location":"network-states/#isinit","text":"This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; }","title":"isInit"},{"location":"network-states/#ispending","text":"This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; }","title":"isPending"},{"location":"network-states/#issuccess","text":"This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; }","title":"isSuccess"},{"location":"network-states/#iserror","text":"This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; }","title":"isError"},{"location":"network-states/#interoperability","text":"While the NetworkStates s are tempting, there might be instances where you still need to use Promises . Therefore, Mycoriza provides two additional hooks to support this interoperability.","title":"Interoperability"},{"location":"network-states/#useasnetworkstate-hook","text":"Features like async-storage and permissions in react-native uses Promise . To port those features to the NetworkState , Mycoriza provides useAsNetworkState hook. This hook accepts a function which provides a promise, and returns the regular Mycoriza hook results. The hook can be used as below. function MyComponent() { const [state, execute] = useAsNetworkState(() => new Promise((resolve, reject) => { ... }) useEffect(() => { if(isSuccess(state)) { //do on success } else if (isError(state)) { //do on error } }, [state.state]) return null; }","title":"useAsNetworkState hook"},{"location":"network-states/#useaspromise-hook","text":"When dealing with asynchronous behaviors, most of the libraries out there requires promises. In order to support this functionality, Mycoriza provides useAsPromise hook. This hook accepts a regular Mycoriza generated hook result and returns a function which creates a Promise . Each time the result function is called, it creates a promise and upon network sate change to terminated state, the promise completes. The hook can be used as below. function MyComponent() { const fetchData = useAsPromise(useDataAsNetworkState()); useEffect(() => { fetchData().then(data => { //Do on data }).catch(e => { //Do on error }) }, []) return null; }","title":"useAsPromise hook"},{"location":"network-states/#useasnullable-hook","text":"useAsNullable hook is defined for a common but a specific case. Generally, a top level component in the component hierarchy handles the network status and the components in the success branch does not have any interest in the failure cases. In such components, having the status checks is unnecessary. Therefore, the useAsNullable hook is defined to convert the NetworkState to nullable value. With useAsNullable hook, the first parameter of the result is unwrapped. if the state is a success, the data in the state is returned; otherwise, undefined is returned. This hook can be used as below. function MyComponent() { const [data, fetch, clear] = useAsNullable(useDataAsNetworkState()); useEffect(() => { //Fetch Data. fetch() }, []) return <>{!!data && <>{JSON.stringify(data)}</>}</>; }","title":"useAsNullable hook."},{"location":"patterns-and-best-practices/","text":"Patterns and Best Practices. Throughout our usage of this framework, we have identified several patterns which can be used with the networks state. Conditional returns based on the state. You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; } Conditional rendering within jsx. In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Eager fetching. In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Cleanup upon exit. In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application. Hide intermediate pending state. In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; } Prefer hook for each necessary component over pass-through-props. As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good. Note From v0.0.8 onward a new helper hook is introduced to unwrap the network state. refer useAsNullable hook for the usage and information. Use entityKey to load multiple results for same api. In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Patterns and Best Practices"},{"location":"patterns-and-best-practices/#patterns-and-best-practices","text":"Throughout our usage of this framework, we have identified several patterns which can be used with the networks state.","title":"Patterns and Best Practices."},{"location":"patterns-and-best-practices/#conditional-returns-based-on-the-state","text":"You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; }","title":"Conditional returns based on the state."},{"location":"patterns-and-best-practices/#conditional-rendering-within-jsx","text":"In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Conditional rendering within jsx."},{"location":"patterns-and-best-practices/#eager-fetching","text":"In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Eager fetching."},{"location":"patterns-and-best-practices/#cleanup-upon-exit","text":"In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application.","title":"Cleanup upon exit."},{"location":"patterns-and-best-practices/#hide-intermediate-pending-state","text":"In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; }","title":"Hide intermediate pending state."},{"location":"patterns-and-best-practices/#prefer-hook-for-each-necessary-component-over-pass-through-props","text":"As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good. Note From v0.0.8 onward a new helper hook is introduced to unwrap the network state. refer useAsNullable hook for the usage and information.","title":"Prefer hook for each necessary component over pass-through-props."},{"location":"patterns-and-best-practices/#use-entitykey-to-load-multiple-results-for-same-api","text":"In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Use entityKey to load multiple results for same api."},{"location":"why-mycoriza/","text":"Why Mycoriza? If you are a lead. If you are a developer.","title":"Why Mycoriza?"},{"location":"why-mycoriza/#why-mycoriza","text":"","title":"Why Mycoriza?"},{"location":"why-mycoriza/#if-you-are-a-lead","text":"","title":"If you are a lead."},{"location":"why-mycoriza/#if-you-are-a-developer","text":"","title":"If you are a developer."}]}