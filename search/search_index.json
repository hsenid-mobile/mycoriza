{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mycorrhizae Mycorrhizae are a symbiotic association between plant roots and fungi . Their major role is to enhance nutrient and water uptake by the host plant by exploiting a larger volume of soil than roots alone can do. Mycorrhizae come in a number of forms, dependent upon both host plant and fungal taxonomy. -- J. Dighton, in Encyclopedia of Microbiology (Third Edition), 2009 mycoriza Mycoriza is a typescript library / code generator for integrating Rest API to react applications. Painless Mycoriza makes the Rest API integration ridiculously easy and helps the developers to spend there valuable time on more important problems than network integration. Explicit Mycoriza prefers State based approach to Promise handling, which is natural to react. Safe Mycoriza ensures the type-safety through strong typescript support and integration-safety through easy and typesafe API client generation.","title":"Overview"},{"location":"TODOS/","text":"Todos [ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"TODOS/#todos","text":"[ ] Remove cli-enhance feature. [ ] Write Getting Started Documentation. [ ] Create Site [ ] Refactor CLI And add test cases. [ ] Add test cases for runtime [ ] Implement error handling in runtime.","title":"Todos"},{"location":"cli-usage/","text":"Mycoriza CLI. Mycoriza provides a CLI to generate to the boilerplate and collect necessary configurations. The updateApi task generated by the Mycoriza cra template uses the CLI under the hood. The CLI currently contains following commands. generate:api command. The generate:api command is provided by the mycoriza-cli tool. This command is supposed to, 1. Collect the configurations if not configured. In the first time usage, the command prompts following questions to collect the necessary configurations. 1. What is the OpenAPI specification url? : This specification url is used to fetch the OpenAPI documentation. What is the development base url? : The development base url is used in the development environment to connect to the server. The first entry in the server configuration is used as the default development base url. What is the production base url? : The production base url is the base url used in production build. Usually, in production environments the REST API is configured within the same domain. To use the same domain as the production base url, keep the value empty. The collected information are saved in the mycoriza property in package.json . 2. Fetch API documentation. The command fetches the specification and prepare for the command generation. 3. Generate client code and tests. The client code generated is saved in <project-root>/src/api . The code generated contains, 1. domain types 2. hooks, 3. stubs for the testing. Usage generate:api command is used in the updateApi generated npm action alongside the documentation generation. Mycoriza uses typedoc to generate the documentation and the dependencies should have been added to the package.json under devDependencies. The documentation is saved in <project-root>/docs/api . It includes the generated data types, hooks and the stub related documentations. Bug While the documentation is generated, if the code is not compiling it does not generate the documentation. This is a known issue and currently fix is underway. Warning Mycoriza CLI provides another function called enhance and currently it is unstable. It is advised to not use this feature at the moment.","title":"CLI Usage"},{"location":"cli-usage/#mycoriza-cli","text":"Mycoriza provides a CLI to generate to the boilerplate and collect necessary configurations. The updateApi task generated by the Mycoriza cra template uses the CLI under the hood. The CLI currently contains following commands.","title":"Mycoriza CLI."},{"location":"cli-usage/#generateapi-command","text":"The generate:api command is provided by the mycoriza-cli tool. This command is supposed to,","title":"generate:api command."},{"location":"cli-usage/#1-collect-the-configurations-if-not-configured","text":"In the first time usage, the command prompts following questions to collect the necessary configurations. 1. What is the OpenAPI specification url? : This specification url is used to fetch the OpenAPI documentation. What is the development base url? : The development base url is used in the development environment to connect to the server. The first entry in the server configuration is used as the default development base url. What is the production base url? : The production base url is the base url used in production build. Usually, in production environments the REST API is configured within the same domain. To use the same domain as the production base url, keep the value empty. The collected information are saved in the mycoriza property in package.json .","title":"1. Collect the configurations if not configured."},{"location":"cli-usage/#2-fetch-api-documentation","text":"The command fetches the specification and prepare for the command generation.","title":"2. Fetch API documentation."},{"location":"cli-usage/#3-generate-client-code-and-tests","text":"The client code generated is saved in <project-root>/src/api . The code generated contains, 1. domain types 2. hooks, 3. stubs for the testing.","title":"3. Generate client code and tests."},{"location":"cli-usage/#usage","text":"generate:api command is used in the updateApi generated npm action alongside the documentation generation. Mycoriza uses typedoc to generate the documentation and the dependencies should have been added to the package.json under devDependencies. The documentation is saved in <project-root>/docs/api . It includes the generated data types, hooks and the stub related documentations. Bug While the documentation is generated, if the code is not compiling it does not generate the documentation. This is a known issue and currently fix is underway. Warning Mycoriza CLI provides another function called enhance and currently it is unstable. It is advised to not use this feature at the moment.","title":"Usage"},{"location":"concepts/","text":"Introduction Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in. Generates the Boilerplate There are various tools and tactics used in developing the network layer of react applications. Those solutions provide either a library to use and conventions to follow, or code generation. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library. Encourages Standardized API Integration. Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. Only the OpenAPI v3 is supported at the moment. OpenAPI v2 support is under development. At the moment, the specification should be accessible through http. File based specification is under development. Uses stable stack. The libraries like redux and axios have already mastered their usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration. While Mycoriza uses these technologies, it does not affect the capabilities which those libraries provide. You can use those libraries with their usual behaviors. Simple and Expressive Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience. Uses hooks . Every generated hook follows a consistent syntax much similar to the useState hook. This allows a seamless integration with the react components and provides a pleasant development experience. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/); Favors States to Promises In javascript, promise represents a possibility and the time aspect. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state. Type safe. Mycoriza is written with strong type safety in mind. It supports and makes use of the features like type guards to provide better type safety. Well documented. Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks. Performant Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting. In the end we believe in productivity and performance in both runtime and development/maintenance. Therefore, Mycoriza tries to reduce and furthermore dissipate the complexity of the network integration altogether.","title":"Basic Concepts"},{"location":"concepts/#introduction","text":"Usually integrating the network to a React application is a tedious task and requires manual labor to maintain the network integration layer. Mycoriza simplifies whole network integration overhead and allows you to focus on more important problems than network integration. There are multiple concepts we believe in.","title":"Introduction"},{"location":"concepts/#generates-the-boilerplate","text":"There are various tools and tactics used in developing the network layer of react applications. Those solutions provide either a library to use and conventions to follow, or code generation. Mycoriza prefers code generation as it leverages the network integration burden. This vastly reduces the knowledge cost of the library.","title":"Generates the Boilerplate"},{"location":"concepts/#encourages-standardized-api-integration","text":"Documenting an API is a best practice in API development. Yet, it requires the development time and effort to maintain the API documentation and often sees as an additional task outside the core developments. Mycoriza attempts to change that opinion by offering the tradeoff of Client network API generation to Documentation. Only the OpenAPI v3 is supported at the moment. OpenAPI v2 support is under development. At the moment, the specification should be accessible through http. File based specification is under development.","title":"Encourages Standardized API Integration."},{"location":"concepts/#uses-stable-stack","text":"The libraries like redux and axios have already mastered their usecase well. Mycoriza reuses these specializations and builds upon them. Under the hood, Mycoriza uses redux for state management and axios for the rest API integration. While Mycoriza uses these technologies, it does not affect the capabilities which those libraries provide. You can use those libraries with their usual behaviors.","title":"Uses stable stack."},{"location":"concepts/#simple-and-expressive","text":"Simple code provides fewer defects and pleasant development experience. React provides its own convention of doing things. Mycoriza makes use of these conventions to provide more simple and natural react development experience.","title":"Simple and Expressive"},{"location":"concepts/#uses-hooks","text":"Every generated hook follows a consistent syntax much similar to the useState hook. This allows a seamless integration with the react components and provides a pleasant development experience. const [state, fetchOrUpdate, clear] = useGenertedMethod(/*entityKey*/);","title":"Uses hooks."},{"location":"concepts/#favors-states-to-promises","text":"In javascript, promise represents a possibility and the time aspect. Using the promises in react components is confusing and often leads to bugs. In API response handling, Mycoriza follows more natural approach than promises. Mycoriza converts the promises to states (a.k.a. NetworkState). These generated states follows a predefined and predictable lifecycle. You can write your components to respond to each state and upon NetworkState change the component re-renders with the correct state.","title":"Favors States to Promises"},{"location":"concepts/#type-safe","text":"Mycoriza is written with strong type safety in mind. It supports and makes use of the features like type guards to provide better type safety.","title":"Type safe."},{"location":"concepts/#well-documented","text":"Often times, you may not have the complete understanding of the API you are dealing with. You may need to spend more time on learning the API than developing the application. To reduce this knowledge gap, Mycoriza generates a comprehensive API documentation alongside the api generation. The documentation is organized based on the category and provides the necessary descriptions and examples alongside the generated hooks.","title":"Well documented."},{"location":"concepts/#performant","text":"Mycoriza generates the hooks and reducers separately. Hence, Mycoriza does not affect the current optimization practices like code splitting. In the end we believe in productivity and performance in both runtime and development/maintenance. Therefore, Mycoriza tries to reduce and furthermore dissipate the complexity of the network integration altogether.","title":"Performant"},{"location":"getting-started/","text":"Getting Started The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup. Prerequisites Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed. How to create a project. Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza Post-creation steps. The API client hooks and types can be generated by running following command. cd <project-name> npm run updateApi When the updateApi command runs for the first time, it requests the following configurations. OpenAPI url : the location where the OpenAPI specification can be found. Only the hosted specifications are supported and file based specification configuraiton is under development. Development URL : The server url which the application connect to within the development environment. Production URL : The server url of the production system. If the production url is empty, it uses the application hosted domain as the production URL. Once you complete these steps, you can find the following generated code. Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The easies way of creating a mycoriza react project is through the create-react-app cli. Use following commands to create a react application with mycoriza toolchain setup.","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"Currently, mycoriza supports OpenAPI v3. OpenAPI v2 support is planned to be developed.","title":"Prerequisites"},{"location":"getting-started/#how-to-create-a-project","text":"Run following command to initiate a Mycoriza react project. This will create a react single page web application with necessary dependencies and toolchains. npx create-react-app <project-name> --template mycoriza","title":"How to create a project."},{"location":"getting-started/#post-creation-steps","text":"The API client hooks and types can be generated by running following command. cd <project-name> npm run updateApi When the updateApi command runs for the first time, it requests the following configurations. OpenAPI url : the location where the OpenAPI specification can be found. Only the hosted specifications are supported and file based specification configuraiton is under development. Development URL : The server url which the application connect to within the development environment. Production URL : The server url of the production system. If the production url is empty, it uses the application hosted domain as the production URL. Once you complete these steps, you can find the following generated code. Store The store related configuration can be found in <project-root>/src/store This code is generated only once and can be modified according to the project needs. API The domain types and the hooks can be found in <project-root>/src/api The changes you do in this codebase will be wiped out in each updateApi execution. Mycoriza configurations The configurations you add in the initial data updateApi call, are configurated in the package.json file. Documentation The API might be complicated and may requires additional time to understand. Therefore, a comprehensive documentation is generated during the updateApi phase, This API can be found in <project-root>/docs/api .","title":"Post-creation steps."},{"location":"how-to-test/","text":"Testing components with Mycoriza hooks. Unit testing is a crucial part of software development. Being a state based library, Mycoriza provides the necessary tools to write the unit tests for the components using the mycoriza generated hooks. Mycoriza is backed by redux and redux provides a comprehensive guide on writing testis . It is recommended to refer the material. Setting up the tests. Mycoriza provides a testStore which accepts the generated reducer , middlewares and the stubs which are related to the CUD. Warning Make sure not to include the middlewares which are bound to issue remote calls as it affects the unit testing. Tip The generated stubs are meant to stub the redux-axios-middleware with more control. The testStore can be used alongside the react-redux Provider to create the tests, and the stubs should be initialized with the factory generated. import {render} from '@testing-library/react'; import {Provider} from \"react-redux\"; import {testStore} from \"mycoriza-runtime\"; //Import stubForMyHook ... let myHookStub = stubForMyHook() render(<Provider store={testStore({ rootReducer: rootReducer, stubs: [stubForMyHook] })}><MyComponent/></Provider>); //Use stub within the test ... The created stub can be used within the test. Autogenerated stubs for hooks. Mycoriza generates the stubs alongside the hooks in <hook-name>.test.ts file. These stubs provide following functionalities. get current state. The stub contains the method currentState to get the current network state in the store. currentState method accepts an entityKey , which can be used to identify the unique values. The currentState is a NetworkState and utility functions can be used with the states. import {isSuccess} from \"mycoriza-runtime\"; ... expect(isSuccess(myHookStub.currentState())).toBeTruthy() change states The stub provides four methods to change the state. Each method accepts the entityKey with usual meaning. reset Reset function will set the state to init state myHookStub.reset() toPendingState toPendingState function changes the state to pending state. myHookStub.toPendingState() toSuccessState toSuccessState function changes the state to success state. This function accepts a value of the type T of hook, and stores as the current value. myHookStub.toSuccessState(\"Foo\") toErrorState toErrorState function changes the state to error state. this function accepts a value as an error and stores as the current error. myHookStub.toErrorState(\"Some Error\") Conclusion The Mycoriza test environment is designed to be able to integrate with any testing environment which redux supports, like @react-testing or enzime . Altogether, writing unit tests to observe the behaviors of the components is a best practice and encouraged by Mycoriza. For any enhancement or issue please report an issue in github repository.","title":"Testing Components"},{"location":"how-to-test/#testing-components-with-mycoriza-hooks","text":"Unit testing is a crucial part of software development. Being a state based library, Mycoriza provides the necessary tools to write the unit tests for the components using the mycoriza generated hooks. Mycoriza is backed by redux and redux provides a comprehensive guide on writing testis . It is recommended to refer the material.","title":"Testing components with Mycoriza hooks."},{"location":"how-to-test/#setting-up-the-tests","text":"Mycoriza provides a testStore which accepts the generated reducer , middlewares and the stubs which are related to the CUD. Warning Make sure not to include the middlewares which are bound to issue remote calls as it affects the unit testing. Tip The generated stubs are meant to stub the redux-axios-middleware with more control. The testStore can be used alongside the react-redux Provider to create the tests, and the stubs should be initialized with the factory generated. import {render} from '@testing-library/react'; import {Provider} from \"react-redux\"; import {testStore} from \"mycoriza-runtime\"; //Import stubForMyHook ... let myHookStub = stubForMyHook() render(<Provider store={testStore({ rootReducer: rootReducer, stubs: [stubForMyHook] })}><MyComponent/></Provider>); //Use stub within the test ... The created stub can be used within the test.","title":"Setting up the tests."},{"location":"how-to-test/#autogenerated-stubs-for-hooks","text":"Mycoriza generates the stubs alongside the hooks in <hook-name>.test.ts file. These stubs provide following functionalities.","title":"Autogenerated stubs for hooks."},{"location":"how-to-test/#get-current-state","text":"The stub contains the method currentState to get the current network state in the store. currentState method accepts an entityKey , which can be used to identify the unique values. The currentState is a NetworkState and utility functions can be used with the states. import {isSuccess} from \"mycoriza-runtime\"; ... expect(isSuccess(myHookStub.currentState())).toBeTruthy()","title":"get current state."},{"location":"how-to-test/#change-states","text":"The stub provides four methods to change the state. Each method accepts the entityKey with usual meaning.","title":"change states"},{"location":"how-to-test/#reset","text":"Reset function will set the state to init state myHookStub.reset()","title":"reset"},{"location":"how-to-test/#topendingstate","text":"toPendingState function changes the state to pending state. myHookStub.toPendingState()","title":"toPendingState"},{"location":"how-to-test/#tosuccessstate","text":"toSuccessState function changes the state to success state. This function accepts a value of the type T of hook, and stores as the current value. myHookStub.toSuccessState(\"Foo\")","title":"toSuccessState"},{"location":"how-to-test/#toerrorstate","text":"toErrorState function changes the state to error state. this function accepts a value as an error and stores as the current error. myHookStub.toErrorState(\"Some Error\")","title":"toErrorState"},{"location":"how-to-test/#conclusion","text":"The Mycoriza test environment is designed to be able to integrate with any testing environment which redux supports, like @react-testing or enzime . Altogether, writing unit tests to observe the behaviors of the components is a best practice and encouraged by Mycoriza. For any enhancement or issue please report an issue in github repository.","title":"Conclusion"},{"location":"migration-guide/","text":"","title":"Migrate an existing project"},{"location":"network-states/","text":"A word about NetworkState By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural. Network State Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call. Typesafe Utilities Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows isInit This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; } isPending This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; } isSuccess This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; } isError This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; } Interoperability While the NetworkStates s are tempting, there might be instances where you still need to use Promises . Therefore, Mycoriza provides two additional hooks to support this interoperability. useAsNetworkState hook Features like async-storage and permissions in react-native uses Promise . To port those features to the NetworkState , Mycoriza provides useAsNetworkState hook. This hook accepts a function which provides a promise, and returns the regular Mycoriza hook results. The hook can be used as below. function MyComponent() { const [state, execute] = useAsNetworkState(() => new Promise((resolve, reject) => { ... }) useEffect(() => { if(isSuccess(state)) { //do on success } else if (isError(state)) { //do on error } }, [state.state]) return null; } useAsPromise hook When dealing with asynchronous behaviors, most of the libraries out there requires promises. In order to support this functionality, Mycoriza provides useAsPromise hook. This hook accepts a regular Mycoriza generated hook result and returns a function which creates a Promise . Each time the result function is called, it creates a promise and upon network sate change to terminated state, the promise completes. The hook can be used as below. function MyComponent() { const fetchData = useAsPromise(useDataAsNetworkState()); useEffect(() => { fetchData().then(data => { //Do on data }).catch(e => { //Do on error }) }, []) return null; }","title":"API Response Handling"},{"location":"network-states/#a-word-about-networkstate","text":"By nature, the network calls are asynchronous. Therefore, in most HTTP clients, the network call results are modeled after the promises. The promises work well with javascript, yet in react components, promises makes confusions. Mycoriza prefer states to promise, as handling state is more natural.","title":"A word about NetworkState"},{"location":"network-states/#network-state","text":"Mycoriza introduces a new generic type NetworkState<T> . It follows predefined state flow as follows. Init : This state means that the network call is not yet initiated. Pending : Upon initiating the call, the NetworkState moves to Pending state. Loaders can be rendered within this state Success : NetworkState moves to this state upon a successful completion of the network call. This state contains a a property called data which contains the result of the execution. Error : NetworkState moves to this state upon a failure of the network call. This state contains the metadata about the failure of the network call.","title":"Network State"},{"location":"network-states/#typesafe-utilities","text":"Some of those utility functions contains additional information related to the operation. To mine out this information, Mycoriza provides a set of utility functions as follows","title":"Typesafe Utilities"},{"location":"network-states/#isinit","text":"This function checks whether the NetworkState is in init state. Usage can be listed as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitStateContent/> } return null; }","title":"isInit"},{"location":"network-states/#ispending","text":"This function checks whether the NetworkState is in pending state. Usually the loaders can be rendered in this state. function MyComponent() { const [state] = useYoutGeneratedHook() if (isPending(state)) { return <Loader/> } return null; }","title":"isPending"},{"location":"network-states/#issuccess","text":"This function check whether the NetworkState is in success state. This state contains the result in the data property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() // Following code fails as state is not confirmed to be in Success state. console.log(state.data) if (isSuccess(state)) { return <SuccessContent/> } return null; }","title":"isSuccess"},{"location":"network-states/#iserror","text":"This function check whether the NetworkState is in success state. This state contains the error in the error property. It can be used as follows. function MyComponent() { const [state] = useYoutGeneratedHook() if (isError(state)) { return <Error/> } return null; }","title":"isError"},{"location":"network-states/#interoperability","text":"While the NetworkStates s are tempting, there might be instances where you still need to use Promises . Therefore, Mycoriza provides two additional hooks to support this interoperability.","title":"Interoperability"},{"location":"network-states/#useasnetworkstate-hook","text":"Features like async-storage and permissions in react-native uses Promise . To port those features to the NetworkState , Mycoriza provides useAsNetworkState hook. This hook accepts a function which provides a promise, and returns the regular Mycoriza hook results. The hook can be used as below. function MyComponent() { const [state, execute] = useAsNetworkState(() => new Promise((resolve, reject) => { ... }) useEffect(() => { if(isSuccess(state)) { //do on success } else if (isError(state)) { //do on error } }, [state.state]) return null; }","title":"useAsNetworkState hook"},{"location":"network-states/#useaspromise-hook","text":"When dealing with asynchronous behaviors, most of the libraries out there requires promises. In order to support this functionality, Mycoriza provides useAsPromise hook. This hook accepts a regular Mycoriza generated hook result and returns a function which creates a Promise . Each time the result function is called, it creates a promise and upon network sate change to terminated state, the promise completes. The hook can be used as below. function MyComponent() { const fetchData = useAsPromise(useDataAsNetworkState()); useEffect(() => { fetchData().then(data => { //Do on data }).catch(e => { //Do on error }) }, []) return null; }","title":"useAsPromise hook"},{"location":"patterns-and-best-practices/","text":"Patterns and Best Practices. Throughout our usage of this framework, we have identified several patterns which can be used with the networks state. Conditional returns based on the state. You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; } Conditional rendering within jsx. In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Eager fetching. In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Cleanup upon exit. In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application. Hide intermediate pending state. In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; } Prefer hook for each necessary component over pass-through-props. As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good. Use entityKey to load multiple results for same api. In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Patterns and Best Practices"},{"location":"patterns-and-best-practices/#patterns-and-best-practices","text":"Throughout our usage of this framework, we have identified several patterns which can be used with the networks state.","title":"Patterns and Best Practices."},{"location":"patterns-and-best-practices/#conditional-returns-based-on-the-state","text":"You can explicitly return the content based on the state. This allows more control over the component rendering as each content to be returned is explicit. import {isError, isPending, isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() if (isInit(state)) { return <InitContent/> } if (isPending(state)) { return <Loading/> } if (isError(state)) { return <ErrorContent error={state.error}/> } return <SuccessContent data={state.data} />; }","title":"Conditional returns based on the state."},{"location":"patterns-and-best-practices/#conditional-rendering-within-jsx","text":"In cases where only one of the states makes sense, it can be used as follows. In here isSuccess() acts as a boolean result generator. import {isSuccess} from \"mycoriza-runtime\"; function MyComponent() { const [state] = useYoutGeneratedHook() return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Conditional rendering within jsx."},{"location":"patterns-and-best-practices/#eager-fetching","text":"In some cases the data should be fetched as soon as the component is loaded. We can use useEffect hook to emmulate this functionality. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData] = useYoutGeneratedHook() useEffect(() => { fetchData() }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; }","title":"Eager fetching."},{"location":"patterns-and-best-practices/#cleanup-upon-exit","text":"In some cases the stale data may affect the future of the application flow. For an example stale product in a product page may result a flashy view of the stale product before loading the correct page. To prevent such situations, the cleanup function can be used to cleanup the state. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [state, fetchData, clear] = useYoutGeneratedHook() //Execute fetchData whenever you need. useEffect(() => { return clear; }, []) return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} </div>; } Upon component unload, above code will clear the relevant network state in the application.","title":"Cleanup upon exit."},{"location":"patterns-and-best-practices/#hide-intermediate-pending-state","text":"In some cases, showing a loader for intermediate data fetching is unnecessary. For an example it is weird to see a loader while searching and filter a list in a list page. To handle such scenarios the network state can be locally cached. import {isSuccess, isPending, isError} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [networkState, fetchData, clear] = useYoutGeneratedHook() const [state, setState] = useState<NetworkState<unknown>>(networkState) //Execute fetchData whenever you need. useEffect(() => { if (!isPending(networkState)) { setState(networkState) } }, [networkState]); return <div> {isSuccess(state) && <SuccessContent data={state.data}/>} {isError(state) && <Error error={state.error}/>} </div>; }","title":"Hide intermediate pending state."},{"location":"patterns-and-best-practices/#prefer-hook-for-each-necessary-component-over-pass-through-props","text":"As the network state adds additional wrapper over original data, naturally developers tend to unwrap the state and pass through the props. This leads component coupling. If you feel like your component is an independent component , do not pass the content as props. Coupled code Following code is too coupled import {isSuccess} from \"mycoriza-runtime\"; interface ComponentAProps { data: any } //This component contains a dependency and coupled with ComponentB. function ComponentA({data}: ComponentAProps) { return <>{JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <> {isSuccess(state) && <ComponentA data={state.data}/> } </> } Independent code Following components are independent. import {isSuccess} from \"mycoriza-runtime\"; //This component is independent and can be used anyware it is needed. function ComponentA() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && JSON.stringify(data)}</> } function ComponentB() { const [state] = useYoutGeneratedHook() return <>{isSuccess(state) && <ComponentA/> }</> } However, if you are developing a component which is not exposed outside the module and does not have any intention of reusing, first code is good.","title":"Prefer hook for each necessary component over pass-through-props."},{"location":"patterns-and-best-practices/#use-entitykey-to-load-multiple-results-for-same-api","text":"In some cases we need to keep different results for the same API call simultaneously. Mycoriza provides the inbuilt support for this. In the generated hooks, first parameter is an entity key, by adding a unique entity key, you can keep different results at the same time. import {isSuccess} from \"mycoriza-runtime\"; import {useEffect} from \"react\"; function MyComponent() { const [product1State, fetchProduct1] = useFetchProduct(\"product-id-1\") const [product2State, fetchProduct2] = useFetchProduct(\"product-id-2\") useEffect(() => { fetchProduct1({id: \"product-id-1\"}) fetchProduct2({id: \"product-id-2\"}) }, []) return <div> {isSuccess(product1State) && <ProductView data={product1State.data}/>} {isSuccess(product2State) && <ProductView data={product2State.data}/>} </div>; }","title":"Use entityKey to load multiple results for same api."},{"location":"why-mycoriza/","text":"Why Mycoriza? If you are a lead. If you are a developer.","title":"Why Mycoriza?"},{"location":"why-mycoriza/#why-mycoriza","text":"","title":"Why Mycoriza?"},{"location":"why-mycoriza/#if-you-are-a-lead","text":"","title":"If you are a lead."},{"location":"why-mycoriza/#if-you-are-a-developer","text":"","title":"If you are a developer."}]}